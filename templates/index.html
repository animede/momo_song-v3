<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>音楽生成</title>
    <!-- 外部CSSを読み込む -->
    <link rel="stylesheet" href="/static/style.css">
  </head>

  <body>

    <div class="content-wrapper">
      <!-- 動画と画像をラップするコンテナ -->
      <div id="media-container">
        <img
          id="base_img"
          src="/static/megu_song.png"
          alt="背景画像"
          style="width:100%; height:auto; display:block; margin-top:20px;"
        />
        <div id="loading-spinner"></div>
        <div id="status" class="status-text"></div>
       <!-- ここで生成済み歌詞をバックグランドimgにオーバーラップ -->
        <div class="overlay-text_a">
          <pre id="result_title_a" style="margin-top: 5px;font-size: 1.3rem; line-height:1.4;"></pre>
          <br>
          <pre id="lyrics_a"></pre>
        </div>         
        <!-- 生成後に切り替える画像 -->
        <div class="overlay-container" style="position: relative;">
          <img
            id="image"
            alt="Generated Image"
            style="display:none; width:100%; height:auto;"
          />
          <!-- ここでリングを追加 -->
          <div id="pulse-ring"></div>
          <!-- ここで歌詞を切り替え画像にオーバーラップ -->
          <div class="overlay-text">
            <pre id="result_title" style="margin-top: 5px;font-size: 1.5rem; line-height:1.4;"></pre>
            <br>
            <pre id="lyrics"></pre>
          </div> 
        </div> 
      </div>
      <div id="result" style="margin-top:10px">
        <h3>音楽の解説</h3>
        <p id="music_text" style="margin-top:-10px; font-size:1rem; color:#333;"></p>
      </div>

      <!-- 新：Flex コンテナでラップ -->
      <div class="input-group">
        <textarea
            id="user_input"
            name="user_input"
            rows="4"
            cols="50"
            placeholder="ここに生成したい曲のイメージや指示を入力してください。たとえば、ジャンルやムード、楽器の指定などを含めると良いでしょう。指定がなければ、おまかせで生成します。"
          ></textarea>
        <div class="button-wrapper" style="margin-top:0px">
          <!-- ボタンを横並びにまとめる行 -->
          <div class="button-row">
            <button id="generate_btn">音楽生成</button>
            <button id="back_btn">戻る</button>
            <button id="save_btn">保存</button>
          </div>
        </div>
      </div>

      <form id="generate_form" onsubmit="return false;" style="margin-top:10px">
        <div class="controls-wrapper">
          <div class="form-section">
            <!-- アコーディオン本体 -->
            <div class="accordion">
              <!-- 開閉用チェックボックス（非表示） -->
              <input type="checkbox" id="params_toggle" class="accordion-toggle" />
              <!-- 押せる見出し -->
              <label for="params_toggle" class="accordion-label">
              生成パラメータ
              </label>
              <!-- 折りたたみ中身 -->
              <div class="accordion-content">
                <!-- テキスト入力群 -->
                <div class="form-item">
                  <label for="title">タイトル（任意）</label>
                  <input type="text" id="title" name="title" placeholder="タイトルを入力">
                </div>
                <div class="form-item">
                  <label for="genre">ジャンル（任意）</label>
                  <input type="text" id="genre" name="genre" placeholder="例：ポップ、ジャズ">
                </div>
                <div class="form-item">
                  <label for="mood">ムード（任意）</label>
                  <input type="text" id="mood" name="mood" placeholder="例：明るい、落ち着いた">
                </div>
                <div class="form-item">
                  <label for="instruments">楽器（任意）</label>
                  <input type="text" id="instruments" name="instruments" placeholder="例：ギター、ピアノ">
                </div>
                <!-- スライダー群 -->
                <div class="slider-container">
                  <div class="slider-item">
                    <label for="infer_step">infer_step</label>
                    <input type="range" id="infer_step" name="infer_step"
                      min="20" max="200" step="1" value="100"
                      oninput="document.getElementById('infer_step_value').textContent = this.value" />
                    <span id="infer_step_value">100</span>
                  </div>
                  <div class="slider-item">
                    <label for="guidance_scale">guidance_scale</label>
                    <input type="range" id="guidance_scale" name="guidance_scale"
                      min="1" max="50" step="0.1" value="15"
                      oninput="document.getElementById('guidance_scale_value').textContent = this.value" />
                    <span id="guidance_scale_value">15.0</span>
                  </div>
                  <div class="slider-item">
                    <label for="omega_scale">omega_scale</label>
                    <input type="range" id="omega_scale" name="omega_scale"
                      min="5" max="50" step="0.1" value="10"
                      oninput="document.getElementById('omega_scale_value').textContent = this.value" />
                    <span id="omega_scale_value">10</span>
                  </div>
                </div>
                <div class="form-item display-params" style="margin-top: 10px;">
                  <strong>表示パラメータ</strong>
                  <div style="margin-top: 5px;">
                    <label>画像サイズ:</label>
                    <label><input type="radio" name="img_aspect" value="16:9" checked>16:9</label>
                    <label><input type="radio" name="img_aspect" value="4:3">4:3</label>
                  </div>
                  <div style="margin-top: 5px;">
                    <label>向き:</label>
                    <label><input type="radio" name="img_orientation" value="landscape" checked>横</label>
                    <label><input type="radio" name="img_orientation" value="portrait">縦</label>
                  </div>
                </div>
                <div class="form-item" style="margin-top: 10px;">
                  <strong>音楽設定</strong>
                  <div style="margin-top: 5px;">
                    <label>
                      <input type="checkbox" id="no_vocal" name="no_vocal" onchange="updateVocalStatus()">
                      ボーカルなしバージョン
                    </label>
                    <span id="vocal_status" style="margin-left: 10px; font-size: 0.9em; color: #666;"></span>
                  </div>
                </div>               
              </div>
            </div>
          </div><!-- /.form-section -->
          <!-- ② オーディオタグを右側に配置 -->
          <div class="audio-container">
            <!-- 音声再生用オーディオタグ -->
            <audio id="audio_player" controls autoplay style="display: block; margin-top:10px; margin-left:-15px;">
            お使いのブラウザはaudio要素に対応していません。
            </audio>
          </div>
        </div>
        <div class="slider-item">
          <label style="margin-left:10px;">
            <input type="checkbox" id="auto_generate_chk">自動生成
          </label>
        </div>     
      </form>
    </div>

    <script>
      const spinner     = document.getElementById('loading-spinner');
      const generateBtn = document.getElementById('generate_btn');
      const backBtn = document.getElementById('back_btn');
      const resultDiv = document.getElementById('result');
      const audioPlayer = document.getElementById('audio_player');
      const videoPlayer  = document.getElementById('base_img');
      const statusEl = document.getElementById('status');
      const BASE_HUE = 240; // 0=赤, 120=緑, 240=青 など

      spinner.style.display = 'none';

      // ボーカル状態を更新する関数
      function updateVocalStatus() {
        const vocalStatus = document.getElementById('vocal_status');
        const noVocalChecked = document.getElementById('no_vocal').checked;
        if (noVocalChecked) {
          vocalStatus.textContent = '(インストゥルメンタル版を生成)';
          vocalStatus.style.color = '#ff6b35';
        } else {
          vocalStatus.textContent = '(ボーカル版を生成)';
          vocalStatus.style.color = '#666';
        }
      }

      // ページ読み込み時に初期状態を設定
      updateVocalStatus();

      // 再生・画像アップデート用のキュー
      const playQueue = [];
      let isPlaying = false;
      let isGenerating = false; // 生成中フラグを追加

// 画像生成ボタン押下時などに呼び出す
function getImageSizeParams() {
  const aspect = document.querySelector('input[name="img_aspect"]:checked').value;
  const orientation = document.querySelector('input[name="img_orientation"]:checked').value;

  // デフォルト値
  let width = 1296, height = 728;

  if (aspect === "16:9") {
    if (orientation === "landscape") {
      width = 1296; height = 728;
    } else {
      width = 728; height = 1296;
    }
  } else if (aspect === "4:3") {
    if (orientation === "landscape") {
      width = 1024; height = 768;
    } else {
      width = 768; height = 1024;
    }
  }
  return { width, height };
}


      // キュー監視・処理関数
      async function processPlayQueue() {
        if (isPlaying) return; // 再生中なら何もしない
        //if (playQueue.length === 0) return; // キューが空なら何もしない
        if (playQueue.length === 0) {
          setTimeout(processPlayQueue, 500);
          return;
        }
        // キューからデータを取り出す
        const item = playQueue.shift();
        isPlaying = true;
        // ここで画像・歌詞・音声を更新
        document.getElementById('result_title').textContent = item.titleText;
        document.getElementById('lyrics').textContent = item.plainText;
        document.getElementById('image').src = item.image_base64;
        document.getElementById('image').style.display = 'block';
        document.querySelector('.overlay-text_a').style.display = 'none';
        document.querySelector('.overlay-text').style.display = 'block';
        audioPlayer.src = item.audio_base64;
        audioPlayer.style.display = 'block';
        videoPlayer.style.display = 'none';
        resultDiv.style.display = 'block';
        updateStatus('作曲終了…');
        setTimeout(processPlayQueue, 500);
        // ★ここを追加　再生の確実性が上がります
        try {
          await audioPlayer.play();
        } catch (e) {
          console.warn('Audio play failed:', e);
        }

      }

      // audioPlayerの再生終了時に次のキューを処理
      audioPlayer.addEventListener('ended', () => {
        isPlaying = false;
        processPlayQueue();
      });

      // 初回起動時に監視開始
      processPlayQueue();     

      // 2. 自動生成用のタイマー・状態管理
      let autoGenerateEnabled = false;
      let lastUserAction = Date.now(); // ←ここを修正
      const AUTO_GENERATE_IDLE = 60000;     // 60秒間操作がなければ発動
      
      // エラー回復機能用の変数
      let consecutiveErrors = 0;           // 連続エラー回数
      const MAX_CONSECUTIVE_ERRORS = 3;    // 最大連続エラー回数
      const ERROR_RETRY_DELAY = 10000;     // エラー後のリトライ間隔（10秒）
      let isInErrorRecovery = false;       // エラー回復モード中フラグ

      const autoGenerateChk = document.getElementById('auto_generate_chk');

      let isAutoGenerating = false;

      // 3. generateBtnクリック関数をラップ（エラー回復機能付き）
      async function triggerGenerate() {
        if (isGenerating) return; // 生成中はスキップ
        
        // 連続エラーが最大値を超えた場合は自動生成を停止
        if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
          console.warn(`連続エラーが${MAX_CONSECUTIVE_ERRORS}回発生したため自動生成を停止します`);
          updateStatus(`連続エラーにより自動生成を停止しました（${consecutiveErrors}回）`);
          autoGenerateChk.checked = false;
          disableAutoGenerate();
          return;
        }
        
        isAutoGenerating = true;
        generateBtn.click();
      }

      // エラー回復のためのリトライ機能
      function scheduleErrorRecovery() {
        if (!autoGenerateEnabled) return;
        
        isInErrorRecovery = true;
        updateStatus(`エラー回復中... ${ERROR_RETRY_DELAY/1000}秒後にリトライします`);
        
        setTimeout(() => {
          if (autoGenerateEnabled && !isGenerating) {
            console.log(`エラー回復リトライ実行（連続エラー数: ${consecutiveErrors}）`);
            isInErrorRecovery = false;
            triggerGenerate();
          }
        }, ERROR_RETRY_DELAY);
      }

      // 生成成功時のエラーカウンターリセット
      function resetErrorCounter() {
        if (consecutiveErrors > 0) {
          console.log(`エラーカウンターをリセット（前回: ${consecutiveErrors}回）`);
          consecutiveErrors = 0;
        }
      }

      // 4. 自動生成の有効化・無効化
      function enableAutoGenerate() {
        autoGenerateEnabled = true;
      }
      function disableAutoGenerate() {
        autoGenerateEnabled = false;
      }

      // 5. チェックボックスのイベント
      autoGenerateChk.addEventListener('change', (e) => {
        if (e.target.checked) {
          enableAutoGenerate();
          // チェックON時に即座に生成を開始するため、lastUserActionを過去にする
          lastUserAction = Date.now() - AUTO_GENERATE_IDLE - 1;
          checkAutoGenerateIdle(); // ← チェックON時に即時チェックして生成開始
        } else {
          disableAutoGenerate();
        }
      });

      // 6. ユーザー操作検知で自動生成を無効化
      ['keydown', 'mousedown', 'touchstart', 'input'].forEach(evt => {
        document.addEventListener(evt, () => {
          lastUserAction = Date.now();
          if (autoGenerateEnabled) {
            autoGenerateChk.checked = false;
            disableAutoGenerate();
            // ユーザー操作時にエラーカウンターもリセット
            resetErrorCounter();
            isInErrorRecovery = false;
          }
        }, true);
      });

      // 8. 一定時間操作がなければ自動生成（playQueueが空のときのみ発動、再生中でもOK）
      function checkAutoGenerateIdle() {
        console.log("checkAutoGenerateIdle called");
        console.log("playQueue.length =", playQueue.length);
        console.log("autoGenerateEnabled=", autoGenerateEnabled);
        console.log("lastUserAction=", lastUserAction);
        console.log("consecutiveErrors=", consecutiveErrors);
        console.log("isInErrorRecovery=", isInErrorRecovery);

        if (
          autoGenerateEnabled &&
          !isInErrorRecovery &&  // エラー回復中でない
          Date.now() - lastUserAction >= AUTO_GENERATE_IDLE &&
          playQueue.length === 0 // キューが空のときのみ自動生成
        ) {
          triggerGenerate();
        }
        setTimeout(checkAutoGenerateIdle, 3000); // 3秒ごとにチェック
      }
      checkAutoGenerateIdle();

      // 初期状態：動画を表示、結果領域とオーディオは非表示
      generateBtn.addEventListener('click', async () => {
        if (isGenerating) return; // 二重実行防止
        isGenerating = true;      // 生成中フラグON       
        if (!isAutoGenerating) {
          document.getElementById('image').style.display = 'none';
          videoPlayer.style.display = 'block';
          document.querySelector('.overlay-text').style.display = 'none';
          document.getElementById('music_text').textContent =  ""
          }
          if (!isPlaying) {
            // 再生中でなければスピナーとステータスを表示
            // 生成中スピナーを表示
            spinner.style.display = 'block';
            statusEl.style.display = 'block';
            updateStatus('作詞・曲データ作成中');
          }

          // Allow the browser to render the spinner before proceeding
          await new Promise(resolve => setTimeout(resolve, 0));         

          // 元のプロンプト取得
          const basePrompt = document.getElementById('user_input').value.trim();
          // 任意入力取得
          const title       = document.getElementById('title').value.trim();
          const genre       = document.getElementById('genre').value.trim();
          const mood        = document.getElementById('mood').value.trim();
          const instruments = document.getElementById('instruments').value.trim();
          // ひとつの文字列にまとめる
          let fullPrompt = basePrompt;
          if (title)       fullPrompt += `\nタイトル: ${title}`;
          if (genre)       fullPrompt += `\nジャンル: ${genre}`;
          if (mood)        fullPrompt += `\nムード: ${mood}`;
          if (instruments) fullPrompt += `\n楽器: ${instruments}`;

          let lyrics_dict;
          let music_world;
          let data_music_world;
          let error=false
          const formData0 = new FormData();
          formData0.append('user_input', fullPrompt);
          formData0.append('previouse_title', title);
          formData0.append('no_vocal', document.getElementById('no_vocal').checked);
          try {
            const response = await fetch('/generate_lyrics', { method: 'POST', body: formData0 });
          if (!response.ok) {
              consecutiveErrors++;
              console.error(`作詞エラー（連続${consecutiveErrors}回目）:`, response.status, response.statusText);
              
              if (isAutoGenerating) {
                // 自動生成モード時はエラー回復を試行
                spinner.style.display = 'none';
                statusEl.style.display = 'none';
                isGenerating = false;
                isAutoGenerating = false;
                scheduleErrorRecovery();
                return;
              } else {
                // 手動生成時は従来通りエラー表示
                statusEl.textContent = `作詞・曲データ作成に失敗しました。言葉を変えて再度お試しください。`;
                spinner.style.display = 'none';
                error=true;
                isGenerating = false;
                isAutoGenerating = false;
                return;
              }
            }

          else {
              error=false;
            }
          const data = await response.json();
          data_music_world = JSON.stringify(data.music_world);
          music_world = data.music_world.message;
          console.log("data_music_world=", data_music_world);
          lyrics_dict = JSON.stringify(data.lyrics_dict);
                  } catch (err) {
            consecutiveErrors++;
            console.error(`作詞処理エラー（連続${consecutiveErrors}回目）:`, err);
            
            if (isAutoGenerating) {
              // 自動生成モード時はエラー回復を試行
              spinner.style.display = 'none';
              statusEl.style.display = 'none';
              isGenerating = false;
              isAutoGenerating = false;
              scheduleErrorRecovery();
              return;
            } else {
              // 手動生成時は従来通りエラー表示
              alert(err.message);
              error=true;
              isGenerating = false;
              isAutoGenerating = false; // ★ここで必ずリセット
              return;
            }
          }
          console.log("lyrics_dict=", lyrics_dict);
          const lyrics_dict_js = JSON.parse(lyrics_dict);
          console.log("lyrics_dict_js=", lyrics_dict_js);
          const m_title= lyrics_dict_js.title;
          console.log("xxx m_title=", m_title);
          document.getElementById('result_title_a').textContent = m_title;
          const lyrics_section= lyrics_dict_js.lyrics;
          console.log("lyrics_section=", lyrics_section);
          const lyrics_Text = Object.values(lyrics_section).join('\n');
          const lyricsL_txt_lines = lyrics_Text.split('\n').map(line => line.trim()).filter(line => line);
          console.log("lyricsL_txt_lines=", lyricsL_txt_lines);
          if (lyricsL_txt_lines[0].length === 1) {
            consecutiveErrors++;
            console.error(`歌詞生成不良（連続${consecutiveErrors}回目）: 歌詞が短すぎます`);
            
            if (isAutoGenerating) {
              // 自動生成モード時はエラー回復を試行
              spinner.style.display = 'none';
              statusEl.style.display = 'none';
              isGenerating = false;
              isAutoGenerating = false;
              scheduleErrorRecovery();
              return;
            } else {
              // 手動生成時は従来通りエラー表示
              statusEl.textContent = `歌詞が生成されませんでした。言葉を変えて再度お試しください。`;
              spinner.style.display = 'none';
              error=true;
              isGenerating = false;
              isAutoGenerating = false; // ★ここで必ずリセット
              return;
            }
          }
          // 自動生成時は歌詞・タイトル・説明文のHTML書き込みをスキップ
          if (!isAutoGenerating) {
                console.log("xxx lyrics_Text=", lyrics_Text);
                document.getElementById('lyrics_a').textContent = lyrics_Text;
                document.querySelector('.overlay-text_a').style.display = 'block';
        
                // 曲の説明文抽出　lyrics_Textをリスト化（改行区切り）
                const lyricsLines = lyrics_Text.split('\n').map(line => line.trim()).filter(line => line);
                let musicMessage = music_world;// music_worldの本文
                // 各歌詞文をmusic_worldから削除
                lyricsLines.forEach(line => {
                  musicMessage = musicMessage.replace(line, '');// 余分な空白も考慮して削除
                });
                musicMessage = musicMessage.replace(/---/g, '');      // --- を削除
                musicMessage = musicMessage.replace(/\n/g, '').trim();// 改行を削除し、前後の空白もトリム
                console.log("musicMessage=", musicMessage);
                // HTML に書き込む
                const musicTextEl = document.getElementById('music_text');
                musicTextEl.textContent =  musicMessage;
                  }
          updateStatus('作詞完了・作曲開始');
  
  // ★ここで画像サイズパラメータを取得
  const { width, height } = getImageSizeParams();

          const formData = new FormData();
          formData.append('lyrics_dict', lyrics_dict);
          // --- スライダーの値をここで form に追加 ---
          formData.append('infer_step', document.getElementById('infer_step').value);
          formData.append('guidance_scale', document.getElementById('guidance_scale').value);
          formData.append('omega_scale', document.getElementById('omega_scale').value);
          formData.append('music_world', data_music_world);
          formData.append('height', height);
          formData.append('width', width);
          // ボーカルなしチェックボックスの値を追加
          const noVocalChecked = document.getElementById('no_vocal').checked;
          console.log("ボーカルなしチェックボックス状態:", noVocalChecked);
          formData.append('no_vocal', noVocalChecked);
          
        
          try {
            const response = await fetch('/generate_music', { method: 'POST', body: formData });
            if (!response.ok) {
              consecutiveErrors++;
              console.error(`音楽・画像生成エラー（連続${consecutiveErrors}回目）:`, response.status, response.statusText);
              
              if (isAutoGenerating) {
                // 自動生成モード時はエラー回復を試行
                spinner.style.display = 'none';
                statusEl.style.display = 'none';
                isGenerating = false;
                isAutoGenerating = false;
                scheduleErrorRecovery();
                return;
              } else {
                // 手動生成時は従来通りエラー表示
                statusEl.textContent = `作曲に失敗しました。言葉を変えて再度お試しください。`;
                spinner.style.display = 'none';
                error=true;
                isGenerating = false;
                isAutoGenerating = false;
                return;
              }
            }
            const data = await response.json();
            const lyrics_json_list = parseToList(data.lyrics_json);
            const titleText = lyrics_json_list[0].value;
            const sections = Object.values(lyrics_json_list[1].value);
            const plainText = sections.join('\n\n');
            
            // 生成成功時にエラーカウンターをリセット
            resetErrorCounter();
            
            // スピナーを隠す・ステータスも隠す
            spinner.style.display = 'none';
            statusEl.style.display = 'none';

            // ここでは再生や画像のアップデートはせず、キューに書き込むだけ
            console.log("push music and imae")
            playQueue.push({
              titleText,
              plainText,
              image_base64: data.image_base64,
              audio_base64: data.audio_base64
            });

        } catch (err) {
          consecutiveErrors++;
          console.error(`音楽・画像生成処理エラー（連続${consecutiveErrors}回目）:`, err);
          
          if (isAutoGenerating) {
            // 自動生成モード時はエラー回復を試行
            spinner.style.display = 'none';
            statusEl.style.display = 'none';
            isGenerating = false;
            isAutoGenerating = false;
            scheduleErrorRecovery();
          } else {
            // 手動生成時は従来通りエラー表示
            alert(err.message);
            updateStatus('作曲が上手くできませんでした。言葉を変えて再度お試しください。');
            spinner.style.display = 'none';
            isGenerating = false;
            isAutoGenerating = false; // ★ここで必ずリセット
          }
          error=true;
        }
        isGenerating = false;
        isAutoGenerating = false; // 最後に必ずリセット
      });

      function parseToList(jsonStr) {
        const obj = JSON.parse(jsonStr);
        return Object.entries(obj).map(([key, value]) => ({
          key,
          value
        }));
      }

      backBtn.addEventListener('click', () => {
        // 結果領域、オーディオを隠す
        //resultDiv.style.display = 'none';
        audioPlayer.style.display = 'none';
        // 画像とオーバーレイテキストの取得とリセット
        const imageElement = document.getElementById('image');
        const overlayText = document.querySelector('.overlay-text');
        if (imageElement) {
          imageElement.style.display = 'none';
          imageElement.src = '';
        }
        if (overlayText) {
          overlayText.style.display = 'none';
        }
        // タイトルと歌詞 と説明のリセット
        document.getElementById('result_title').textContent = '';
        document.getElementById('lyrics').textContent = '';
        document.getElementById('music_text').textContent =  ""
        // 初期画像を再表示
        videoPlayer.style.display = 'block';
        // 入力ボックスやテキストエリアを初期化
        document.querySelectorAll('input[type="text"], textarea').forEach(el => {
          el.value = '';});
        // 必要ならselectやcheckboxも初期化
        document.querySelectorAll('select').forEach(el => el.selectedIndex = 0);
        document.querySelectorAll('input[type="checkbox"]:not([name="img_aspect"]):not([name="img_orientation"])').forEach(el => el.checked = false);
        document.querySelectorAll('input[type="radio"]').forEach(el => {
          if (el.hasAttribute('checked')) {
            el.checked = true;
          } else {
            el.checked = false;
          }
        });
        pulseRing.style.borderColor = 'transparent';
        //pulseRing.style.boxShadow = 'none';
        
        // エラー状態もリセット
        resetErrorCounter();
        isInErrorRecovery = false;
      });

      // ステータスを更新する関数
      function updateStatus(msg) {
        statusEl.textContent = `${msg}`;
      }

      const pulseRing = document.getElementById('pulse-ring');
      let audioCtx, analyser, source, dataArray;
      // 再生が始まったらオーディオコンテキストをセットアップ
      audioPlayer.addEventListener('play', async () => {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          source = audioCtx.createMediaElementSource(audioPlayer);
          analyser = audioCtx.createAnalyser();
          analyser.fftSize = 256;
          source.connect(analyser);
          analyser.connect(audioCtx.destination);
          dataArray = new Uint8Array(analyser.frequencyBinCount);
        }
        if (audioCtx.state === 'suspended') { // 自動サスペンド対策
          await audioCtx.resume();
        }
        requestAnimationFrame(animatePulse); // アニメーション開始
      });

      // アニメーションループ
      function animatePulse() {
        if (audioPlayer.paused || audioPlayer.ended) {
          pulseRing.style.transform = 'translate(-50%,-50%) scale(1)';
          // サークルの色を初期色に戻す
          //const BASE_HUE = 240; // ここを0(赤), 120(緑), 240(青)などに変更
          pulseRing.style.borderColor = `hsl(${BASE_HUE}, 100%, 50%)`;
          pulseRing.style.borderColor = 'transparent'; // ←ここをtransparentに
          pulseRing.style.boxShadow = 'none';
          return;
        }
        analyser.getByteFrequencyData(dataArray);
        // 音量レベル調整用の倍率
        const VOLUME_GAIN = 1.0; // ←ここで音量感度を調整（例: 2.0で2倍、3.0で3倍など）
        // 音量の平均値を取得し、調整
        let avg = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;
        avg = Math.min(avg * VOLUME_GAIN, 255); // 255を超えないようにクリップ

        const scale = 1 + (avg / 255) * 0.3;
        pulseRing.style.transform = `translate(-50%,-50%) scale(${scale})`;
        // 音量に応じて色を変化させる（例：青→緑→黄→赤）
        // 0〜255を0〜120（色相）にマッピング
        //const hue = 240 - Math.round((avg / 255) * 360); // 240=青, -120=赤紫
        //const BASE_HUE = 240; // ここを0(赤), 120(緑), 240(青)などに変更
        const hue = BASE_HUE - Math.round((avg / 255) * 360);
        pulseRing.style.borderColor = `hsl(${hue}, 100%, 50%)`;
        const saturation = 100;
        const lightness = 50 + (avg / 255) * 20; // 明るさも変化
        pulseRing.style.borderColor = `hsl(${hue}, 100%, 50%)`;
        pulseRing.style.boxShadow = `0 0 30px 10px hsl(${hue}, 100%, 60%, 0.5)`;
        requestAnimationFrame(animatePulse);
      }
      // 保存ボタンの取得
      const saveBtn = document.getElementById('save_btn');
      saveBtn.addEventListener('click', () => {
        // ファイル名（タイトル）を取得
        const title = document.getElementById('result_title_a').textContent.trim() || 'music';
        // 1. 歌詞テキストを保存
        const lyrics = document.getElementById('lyrics_a').textContent;
        const blobTxt = new Blob([lyrics], { type: 'text/plain' });
        const aTxt = document.createElement('a');
        aTxt.href = URL.createObjectURL(blobTxt);
        aTxt.download = `${title}.txt`;
        aTxt.click();
        URL.revokeObjectURL(aTxt.href);
        // 2. オーディオ（mp3/wav）を保存
        // audioPlayer.srcがdata:audio/wav;base64,...形式の場合
        const audioSrc = audioPlayer.src;
        if (audioSrc.startsWith('data:audio/')) {
          const arr = audioSrc.split(',');
          const mime = arr[0].match(/data:audio\/([a-zA-Z0-9]+);base64/)[1];
          const byteString = atob(arr[1]);
          const ab = new ArrayBuffer(byteString.length);
          const ia = new Uint8Array(ab);
          for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
          }
          const blobAudio = new Blob([ab], { type: `audio/${mime}` });
          const aAudio = document.createElement('a');
          aAudio.href = URL.createObjectURL(blobAudio);
          aAudio.download = `${title}.${mime}`;
          aAudio.click();
          URL.revokeObjectURL(aAudio.href);
        } else {
          alert('音声データが見つかりません');
        }
      });
    </script>
 
  </body>
</html>